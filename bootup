#!/usr/bin/env node
var ProgressBar = require('progress'),
    logger = require('npmlog'),
    Systemd = require('./lib/bootup/systemd'),
    Supervisord = require('supervisord'),
    config = require('./config.json'),
    Tail = require('./lib/bootup/tail'),
    settings = require('./settings.json').BOOTUP;

var superv;

var checkRedis = function() {
    logger.info('Redis', 'Checking systemd status...');
    return Systemd.status('redis-server')
        .then(result => {
            if(result.active) {
                return Promise.resolve();
            } else {
                logger.warn('Redis', 'Systemd reports Redis is not active. Attempting start...');
                return Systemd.start('redis-server');
            }
        })
        .then(result => {
            logger.info('Redis', 'Systemd reports Redis is active.');
        })
        .catch(error => {
            logger.error('Redis', `Operation failed.`);
            logger.error('Redis', error)
            process.exit(1);
        });
}

var connectToSupervisor = function() {
    return new Promise((resolve) => {
        logger.info('Supervisord', `Attempting connection to ${settings.SUPERVISOR_URI}`);
        try {
            superv = Supervisord.connect(settings.SUPERVISOR_URI);
            superv.getAPIVersion((err, result) => {
                if(err) {
                    logger.error('Supervisord', 'Error communicating to remote process:');
                    logger.error('Supervisord', err);
                    process.exit(1);
                }
                logger.info('Supervisord', `Connected to remote API serving a v${result} supervisord interface`);
                return Promise.resolve();
            });
        } catch(ex) {
            logger.error('Supervisord', 'Connection failed.');
            logger.error('Supervisord', ex);
            process.exit(1);
        }
    });
}

var ensurePatchPanel = function() {
    logger.info('PatchPanelv4', 'Ensuring process is running...');
    return new Promise((resolve) => {
        superv.startProcess('ppv4', (err, result) => {
            if(err) {
                if(err.faultCode && err.faultCode === 60) {
                    return resolve(false);
                }
                logger.error('PatchPanelv4', 'Starting ppv4 failed with an unknown faultCode.');
                logger.error('PatchPanelv4', `FaultCode: ${err.faultCode} FaultString: ${err.faultString}`);
                logger.error('PatchPanelv4', err);
                process.exit(1);
            }
            if(result) {
                resolve(true);
            } else {
                logger.error('PatchPanelv4', 'Remote process returned an unexpected state. Cannot guarantee system integrity. Please manually check it.');
                process.exit(1);
            }
        });
    });
}

var ensureGateways = function() {
    return new Promise((resolve) => {
        logger.info('GatewayDiscover', 'Performing operations...');
        var knownGateways = [],
            gauge = new ProgressBar(':bar (:current of :total)', { total: settings.GATEWAYS_COUNT }),
            t = new Tail('/tmp/x', 'Auth is GO'),
            regexp = /\[HandlerFSM:\d+:\d+:(\d+)\]: Auth is GO!$/g,
            timeout;

        var resetTimeout = () => {
            if(timeout) {
                clearTimeout(timeout);
            }
            timeout = setTimeout(() => {
                gauge.terminate();
                logger.error('GatewayDiscover', 'Cannot find all gateways.');
                logger.error('Missing: ', Object.keys(config.NodeDistribution).filter(k => knownGateways.indexOf(k) === -1));
                process.exit(1);
            }, settings.GATEWAY_DISCOVER_TIMEOUT * 1000);
        };
        t.onLineReceived((line) => {
            if(regexp.test(line)) {
                var gatewayId = regexp.exec(line)[1];
                if(knownGateways.indexOf(gatewayId) === -1) {
                    knownGateways.push(gatewayId);
                    resetTimeout();
                    if(knownGateways.length > gauge.curr) {
                        for(var i = 0; i < (knownGateways.length - gauge.curr); i++) {
                            gauge.tick();
                        }
                    }
                }
                if(knownGateways.length === settings.GATEWAYS_COUNT) {
                    gauge.terminate();
                    logger.info('Succeeded.');
                    resolve();
                }
            }
        });
        t.start();
        resetTimeout();
    });
};

var checkProcessorState = () => {
    return new Promise(resolve => {
        superv.getProcessInfo('processor', (err, data) => {
            if(err) {
                logger.error('CheckProcessor', 'Cannot get information:');
                logger.error(err);
                process.exit(1);
            }
            return data;
        });
    });
}

var startAnimationMapRouter = () => {
    return new Promise(resolve => {
        logger.info('AnimationMapRouter', 'Starting...');
        superv.startProcess('animationMapRouter', (err, data) => {
            if(err) {
                logger.error('AnimationMapRouter', 'Error starting:');
                logger.error('AnimationMapRouter', err);
                process.exit(1);
                return Promise.reject();
            }
        });
    });
}

var waitRouterEngines = () => {
    return new Promise((resolve, reject) => {
        var gauge = new ProgressBar(':bar (:current of :total)', { total: settings.TOTAL_ENGINES_COUNT }),
            timeout;
        var resetTimeout = () => {
            if(timeout) {
                clearTimeout(timeout);
            }
            timeout = setTimeout(() => {
                if(gauge.curr >= settings.MINIMUM_ENGINES_COUNT) {
                    logger.warn('WaitRouterEngines', `Timeout exceeded. Continuing with minimum engine count (${gauge.curr})`);
                    gauge.terminate();
                    resolve();
                } else {
                    logger.error('WaitRouterEngines', 'Cannot guarantee minimal engine count. Aborting.');
                    process.exit(1);
                    reject();
                }
            }, settings.ENGINE_DISCOVER_TIMEOUT * 1000);
        };

        var t = new Tail('/tmp/x', 'Garanteed'),
            regex = /\s+Garanteed Config'ed (\d+)\s.*$/;
        t.onLineReceived(line => {
            line = line.trim();
            if(regex.test(line)) {
                var currentCount = parseInt(regex.exec(line)[1]);
                if(currentCount > gauge.curr) {
                    for(var i = 0; i < currentCount - gauge.curr; i++) {
                        resetTimeout();
                        gauge.tick();
                    }
                }
                if(gauge.curr === settings.TOTAL_ENGINES_COUNT) {
                    clearTimeout(timeout);
                    gauge.terminate();
                    resolve();
                }
            }
        });
        t.start();
    });
};

var stopAnimationMapRouter = () => {
    return new Promise(resolve => {
        logger.info('AnimationMapRouter', 'Stopping...');
        superv.stopProcess('animationMapRouter', () => {
            resolve();
        });
    });
}

var startSocket = () => {
    return new Promise(resolve => {
        logger.info('Socket', 'Starting...');
        superv.startProcess('socket', () => {
            logger.info('Socket', 'OK');
            resolve();
        });
    });
};

var startProcessor = () => {
    return new Promise(resolve => {
        logger.info('Processor', 'Starting...');
        superv.startProcess('processor', () => {
            logger.info('Processor', 'OK');
            resolve();
        });
    });
}

var performCalibration = () => {
    return new Promise(resolve => {
        logger.info('Calibration', 'Starting...');
        superv.startProcess('calibration', () => {
            logger.info('Calibration', 'Performing. Will take approx. 8 seconds. Hold tight.');
            setTimeout(() => {
                logger.info('Calibration', 'Finishing...');
                superv.stopProcess('calibration', () => {
                    logger.info('Calibration', 'Completed.');
                    resolve();
                });
            }, settings.CALIBRATION_OPERATION_TIME * 1000);
        });
    });
}

checkRedis()
    .then(connectToSupervisor)
    .then(ensurePatchPanel)
    .then((shouldEnsureGateways) => {
        if(shouldEnsureGateways) {
            logger.info('bootup', 'PatchPanel state has changed. Processing gateways...');
            return ensureGateways(); // Auth
        } else {
            logger.info('bootup', 'PatchPanel state hasn\'t changed. Won\'t process gateways.');
            return Promise.resolve();
        }
    })
    .then(checkProcessorState)
    .then(state => {
        if(state.statename !== 'STOPPED') {
            logger.warn('bootup', 'WARNING: System state is not ideal for running this utility.\nCurrently, the supervisord process \'processor\' is active.');
            logger.warn('bootup', 'Cowardly refusing to continue.');
            process.exit(1);
            return Promise.reject();
        }
        return Promise.resolve();
    })
    .then(startAnimationMapRouter)
    .then(waitRouterEngines)
    .then(stopAnimationMapRouter)
    .then(performCalibration) // 8 secs
    .then(startAnimationMapRouter)
    .then(waitRouterEngines)  // 340 motors (Guaranteed)
    .then(startSocket)
    .then(startProcessor);

